// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEVICETOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
#define FLATBUFFERS_GENERATED_DEVICETOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "FirmwareBootType_generated.h"
#include "SemVer_generated.h"

namespace OpenShock {
namespace Serialization {
namespace Gateway {

struct KeepAlive;

struct BootStatus;
struct BootStatusBuilder;

struct OtaInstallStarted;
struct OtaInstallStartedBuilder;

struct OtaInstallProgress;
struct OtaInstallProgressBuilder;

struct OtaInstallFailed;
struct OtaInstallFailedBuilder;

struct DeviceToGatewayMessage;
struct DeviceToGatewayMessageBuilder;

enum class OtaInstallProgressTask : int8_t {
  FetchingMetadata = 0,
  PreparingForInstall = 1,
  FlashingFilesystem = 2,
  VerifyingFilesystem = 3,
  FlashingApplication = 4,
  MarkingApplicationBootable = 5,
  Rebooting = 6,
  MIN = FetchingMetadata,
  MAX = Rebooting
};

inline const OtaInstallProgressTask (&EnumValuesOtaInstallProgressTask())[7] {
  static const OtaInstallProgressTask values[] = {
    OtaInstallProgressTask::FetchingMetadata,
    OtaInstallProgressTask::PreparingForInstall,
    OtaInstallProgressTask::FlashingFilesystem,
    OtaInstallProgressTask::VerifyingFilesystem,
    OtaInstallProgressTask::FlashingApplication,
    OtaInstallProgressTask::MarkingApplicationBootable,
    OtaInstallProgressTask::Rebooting
  };
  return values;
}

inline const char * const *EnumNamesOtaInstallProgressTask() {
  static const char * const names[8] = {
    "FetchingMetadata",
    "PreparingForInstall",
    "FlashingFilesystem",
    "VerifyingFilesystem",
    "FlashingApplication",
    "MarkingApplicationBootable",
    "Rebooting",
    nullptr
  };
  return names;
}

inline const char *EnumNameOtaInstallProgressTask(OtaInstallProgressTask e) {
  if (::flatbuffers::IsOutRange(e, OtaInstallProgressTask::FetchingMetadata, OtaInstallProgressTask::Rebooting)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOtaInstallProgressTask()[index];
}

enum class DeviceToGatewayMessagePayload : uint8_t {
  NONE = 0,
  KeepAlive = 1,
  BootStatus = 2,
  OtaInstallStarted = 3,
  OtaInstallProgress = 4,
  OtaInstallFailed = 5,
  MIN = NONE,
  MAX = OtaInstallFailed
};

inline const DeviceToGatewayMessagePayload (&EnumValuesDeviceToGatewayMessagePayload())[6] {
  static const DeviceToGatewayMessagePayload values[] = {
    DeviceToGatewayMessagePayload::NONE,
    DeviceToGatewayMessagePayload::KeepAlive,
    DeviceToGatewayMessagePayload::BootStatus,
    DeviceToGatewayMessagePayload::OtaInstallStarted,
    DeviceToGatewayMessagePayload::OtaInstallProgress,
    DeviceToGatewayMessagePayload::OtaInstallFailed
  };
  return values;
}

inline const char * const *EnumNamesDeviceToGatewayMessagePayload() {
  static const char * const names[7] = {
    "NONE",
    "KeepAlive",
    "BootStatus",
    "OtaInstallStarted",
    "OtaInstallProgress",
    "OtaInstallFailed",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceToGatewayMessagePayload(DeviceToGatewayMessagePayload e) {
  if (::flatbuffers::IsOutRange(e, DeviceToGatewayMessagePayload::NONE, DeviceToGatewayMessagePayload::OtaInstallFailed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceToGatewayMessagePayload()[index];
}

template<typename T> struct DeviceToGatewayMessagePayloadTraits {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::NONE;
};

template<> struct DeviceToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::KeepAlive> {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::KeepAlive;
};

template<> struct DeviceToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::BootStatus> {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::BootStatus;
};

template<> struct DeviceToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaInstallStarted> {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::OtaInstallStarted;
};

template<> struct DeviceToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaInstallProgress> {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::OtaInstallProgress;
};

template<> struct DeviceToGatewayMessagePayloadTraits<OpenShock::Serialization::Gateway::OtaInstallFailed> {
  static const DeviceToGatewayMessagePayload enum_value = DeviceToGatewayMessagePayload::OtaInstallFailed;
};

bool VerifyDeviceToGatewayMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, DeviceToGatewayMessagePayload type);
bool VerifyDeviceToGatewayMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DeviceToGatewayMessagePayload> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) KeepAlive FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t uptime_;

 public:
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.KeepAlive";
  }
  KeepAlive()
      : uptime_(0) {
  }
  KeepAlive(uint64_t _uptime)
      : uptime_(::flatbuffers::EndianScalar(_uptime)) {
  }
  uint64_t uptime() const {
    return ::flatbuffers::EndianScalar(uptime_);
  }
};
FLATBUFFERS_STRUCT_END(KeepAlive, 8);

struct KeepAlive::Traits {
  using type = KeepAlive;
};

struct BootStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootStatusBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.BootStatus";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOT_TYPE = 4,
    VT_FIRMWARE_VERSION = 6,
    VT_OTA_UPDATE_ID = 8
  };
  OpenShock::Serialization::Types::FirmwareBootType boot_type() const {
    return static_cast<OpenShock::Serialization::Types::FirmwareBootType>(GetField<uint8_t>(VT_BOOT_TYPE, 0));
  }
  const OpenShock::Serialization::Types::SemVer *firmware_version() const {
    return GetPointer<const OpenShock::Serialization::Types::SemVer *>(VT_FIRMWARE_VERSION);
  }
  int32_t ota_update_id() const {
    return GetField<int32_t>(VT_OTA_UPDATE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOT_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyTable(firmware_version()) &&
           VerifyField<int32_t>(verifier, VT_OTA_UPDATE_ID, 4) &&
           verifier.EndTable();
  }
};

struct BootStatusBuilder {
  typedef BootStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_boot_type(OpenShock::Serialization::Types::FirmwareBootType boot_type) {
    fbb_.AddElement<uint8_t>(BootStatus::VT_BOOT_TYPE, static_cast<uint8_t>(boot_type), 0);
  }
  void add_firmware_version(::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> firmware_version) {
    fbb_.AddOffset(BootStatus::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_ota_update_id(int32_t ota_update_id) {
    fbb_.AddElement<int32_t>(BootStatus::VT_OTA_UPDATE_ID, ota_update_id, 0);
  }
  explicit BootStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BootStatus> CreateBootStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::FirmwareBootType boot_type = OpenShock::Serialization::Types::FirmwareBootType::Normal,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> firmware_version = 0,
    int32_t ota_update_id = 0) {
  BootStatusBuilder builder_(_fbb);
  builder_.add_ota_update_id(ota_update_id);
  builder_.add_firmware_version(firmware_version);
  builder_.add_boot_type(boot_type);
  return builder_.Finish();
}

struct BootStatus::Traits {
  using type = BootStatus;
  static auto constexpr Create = CreateBootStatus;
};

struct OtaInstallStarted FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaInstallStartedBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaInstallStarted";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_VERSION = 6
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  const OpenShock::Serialization::Types::SemVer *version() const {
    return GetPointer<const OpenShock::Serialization::Types::SemVer *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           verifier.EndTable();
  }
};

struct OtaInstallStartedBuilder {
  typedef OtaInstallStarted Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaInstallStarted::VT_UPDATE_ID, update_id, 0);
  }
  void add_version(::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version) {
    fbb_.AddOffset(OtaInstallStarted::VT_VERSION, version);
  }
  explicit OtaInstallStartedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaInstallStarted> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaInstallStarted>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaInstallStarted> CreateOtaInstallStarted(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::SemVer> version = 0) {
  OtaInstallStartedBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_update_id(update_id);
  return builder_.Finish();
}

struct OtaInstallStarted::Traits {
  using type = OtaInstallStarted;
  static auto constexpr Create = CreateOtaInstallStarted;
};

struct OtaInstallProgress FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaInstallProgressBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaInstallProgress";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_TASK = 6,
    VT_PROGRESS = 8
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  OpenShock::Serialization::Gateway::OtaInstallProgressTask task() const {
    return static_cast<OpenShock::Serialization::Gateway::OtaInstallProgressTask>(GetField<int8_t>(VT_TASK, 0));
  }
  float progress() const {
    return GetField<float>(VT_PROGRESS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_TASK, 1) &&
           VerifyField<float>(verifier, VT_PROGRESS, 4) &&
           verifier.EndTable();
  }
};

struct OtaInstallProgressBuilder {
  typedef OtaInstallProgress Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaInstallProgress::VT_UPDATE_ID, update_id, 0);
  }
  void add_task(OpenShock::Serialization::Gateway::OtaInstallProgressTask task) {
    fbb_.AddElement<int8_t>(OtaInstallProgress::VT_TASK, static_cast<int8_t>(task), 0);
  }
  void add_progress(float progress) {
    fbb_.AddElement<float>(OtaInstallProgress::VT_PROGRESS, progress, 0.0f);
  }
  explicit OtaInstallProgressBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaInstallProgress> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaInstallProgress>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaInstallProgress> CreateOtaInstallProgress(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    OpenShock::Serialization::Gateway::OtaInstallProgressTask task = OpenShock::Serialization::Gateway::OtaInstallProgressTask::FetchingMetadata,
    float progress = 0.0f) {
  OtaInstallProgressBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_update_id(update_id);
  builder_.add_task(task);
  return builder_.Finish();
}

struct OtaInstallProgress::Traits {
  using type = OtaInstallProgress;
  static auto constexpr Create = CreateOtaInstallProgress;
};

struct OtaInstallFailed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtaInstallFailedBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.OtaInstallFailed";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_MESSAGE = 6,
    VT_FATAL = 8
  };
  int32_t update_id() const {
    return GetField<int32_t>(VT_UPDATE_ID, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool fatal() const {
    return GetField<uint8_t>(VT_FATAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UPDATE_ID, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint8_t>(verifier, VT_FATAL, 1) &&
           verifier.EndTable();
  }
};

struct OtaInstallFailedBuilder {
  typedef OtaInstallFailed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(int32_t update_id) {
    fbb_.AddElement<int32_t>(OtaInstallFailed::VT_UPDATE_ID, update_id, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(OtaInstallFailed::VT_MESSAGE, message);
  }
  void add_fatal(bool fatal) {
    fbb_.AddElement<uint8_t>(OtaInstallFailed::VT_FATAL, static_cast<uint8_t>(fatal), 0);
  }
  explicit OtaInstallFailedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtaInstallFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtaInstallFailed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtaInstallFailed> CreateOtaInstallFailed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    bool fatal = false) {
  OtaInstallFailedBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_update_id(update_id);
  builder_.add_fatal(fatal);
  return builder_.Finish();
}

struct OtaInstallFailed::Traits {
  using type = OtaInstallFailed;
  static auto constexpr Create = CreateOtaInstallFailed;
};

inline ::flatbuffers::Offset<OtaInstallFailed> CreateOtaInstallFailedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t update_id = 0,
    const char *message = nullptr,
    bool fatal = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return OpenShock::Serialization::Gateway::CreateOtaInstallFailed(
      _fbb,
      update_id,
      message__,
      fatal);
}

struct DeviceToGatewayMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceToGatewayMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Gateway.DeviceToGatewayMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload payload_type() const {
    return static_cast<OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OpenShock::Serialization::Gateway::KeepAlive *payload_as_KeepAlive() const {
    return payload_type() == OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::KeepAlive ? static_cast<const OpenShock::Serialization::Gateway::KeepAlive *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::BootStatus *payload_as_BootStatus() const {
    return payload_type() == OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::BootStatus ? static_cast<const OpenShock::Serialization::Gateway::BootStatus *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaInstallStarted *payload_as_OtaInstallStarted() const {
    return payload_type() == OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::OtaInstallStarted ? static_cast<const OpenShock::Serialization::Gateway::OtaInstallStarted *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaInstallProgress *payload_as_OtaInstallProgress() const {
    return payload_type() == OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::OtaInstallProgress ? static_cast<const OpenShock::Serialization::Gateway::OtaInstallProgress *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Gateway::OtaInstallFailed *payload_as_OtaInstallFailed() const {
    return payload_type() == OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::OtaInstallFailed ? static_cast<const OpenShock::Serialization::Gateway::OtaInstallFailed *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyDeviceToGatewayMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OpenShock::Serialization::Gateway::KeepAlive *DeviceToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::KeepAlive>() const {
  return payload_as_KeepAlive();
}

template<> inline const OpenShock::Serialization::Gateway::BootStatus *DeviceToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::BootStatus>() const {
  return payload_as_BootStatus();
}

template<> inline const OpenShock::Serialization::Gateway::OtaInstallStarted *DeviceToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaInstallStarted>() const {
  return payload_as_OtaInstallStarted();
}

template<> inline const OpenShock::Serialization::Gateway::OtaInstallProgress *DeviceToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaInstallProgress>() const {
  return payload_as_OtaInstallProgress();
}

template<> inline const OpenShock::Serialization::Gateway::OtaInstallFailed *DeviceToGatewayMessage::payload_as<OpenShock::Serialization::Gateway::OtaInstallFailed>() const {
  return payload_as_OtaInstallFailed();
}

struct DeviceToGatewayMessageBuilder {
  typedef DeviceToGatewayMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(DeviceToGatewayMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(DeviceToGatewayMessage::VT_PAYLOAD, payload);
  }
  explicit DeviceToGatewayMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceToGatewayMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceToGatewayMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceToGatewayMessage> CreateDeviceToGatewayMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload payload_type = OpenShock::Serialization::Gateway::DeviceToGatewayMessagePayload::NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  DeviceToGatewayMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct DeviceToGatewayMessage::Traits {
  using type = DeviceToGatewayMessage;
  static auto constexpr Create = CreateDeviceToGatewayMessage;
};

inline bool VerifyDeviceToGatewayMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, DeviceToGatewayMessagePayload type) {
  switch (type) {
    case DeviceToGatewayMessagePayload::NONE: {
      return true;
    }
    case DeviceToGatewayMessagePayload::KeepAlive: {
      return verifier.VerifyField<OpenShock::Serialization::Gateway::KeepAlive>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case DeviceToGatewayMessagePayload::BootStatus: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::BootStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToGatewayMessagePayload::OtaInstallStarted: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaInstallStarted *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToGatewayMessagePayload::OtaInstallProgress: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaInstallProgress *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceToGatewayMessagePayload::OtaInstallFailed: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Gateway::OtaInstallFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDeviceToGatewayMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DeviceToGatewayMessagePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDeviceToGatewayMessagePayload(
        verifier,  values->Get(i), types->GetEnum<DeviceToGatewayMessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const OpenShock::Serialization::Gateway::DeviceToGatewayMessage *GetDeviceToGatewayMessage(const void *buf) {
  return ::flatbuffers::GetRoot<OpenShock::Serialization::Gateway::DeviceToGatewayMessage>(buf);
}

inline const OpenShock::Serialization::Gateway::DeviceToGatewayMessage *GetSizePrefixedDeviceToGatewayMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OpenShock::Serialization::Gateway::DeviceToGatewayMessage>(buf);
}

inline bool VerifyDeviceToGatewayMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OpenShock::Serialization::Gateway::DeviceToGatewayMessage>(nullptr);
}

inline bool VerifySizePrefixedDeviceToGatewayMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OpenShock::Serialization::Gateway::DeviceToGatewayMessage>(nullptr);
}

inline void FinishDeviceToGatewayMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::DeviceToGatewayMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDeviceToGatewayMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Gateway::DeviceToGatewayMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gateway
}  // namespace Serialization
}  // namespace OpenShock

#endif  // FLATBUFFERS_GENERATED_DEVICETOGATEWAYMESSAGE_OPENSHOCK_SERIALIZATION_GATEWAY_H_
